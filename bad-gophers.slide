Bad Gophers: unexpected hurdles programming in Go
Sometimes, you have to fight against your own runtime
23 Oct 2018
Tags: containers,golang,goroutines,programming

Francesco Romani
Senior Software Engineer, Red Hat
fromani {gmail,redhat}
http://github.com/{mojaves,fromanirh}

* whoami
- sweng @ Red Hat (but opinions and mistakes are my own!)
- works daily(-ish): libvirt, kvm, python, golang, kubernetes
- interested in: more golang, containers, kubernetes; lisp
- happy linux user (red hat linux, debian, ubuntu, fedora)

* Talk outline

- part 1: a journey in the container world ...

- part 2: ... leading to unexpected hurdles ...

- part 3: ... and how we can overcome them

.link https://github.com/mojaves/ slides and more: github.com/mojaves

* Containers, containers...

.image https://upload.wikimedia.org/wikipedia/commons/7/72/2017-08-28_HS-Reise_Container_an_Deck_der_HEINRICH_SCHEPERS_%282588%29.jpg _ 600
.caption Container an Deck der HEINRICH SCHEPERS by Eduard47, CC BY-SA 4.0, from Wikimedia Commons

* Dramatis Personae

A *container* is a *Linux* *process* (like bash, firefox, thunderbird...) but
*augmented* with a set of the features of the linux kernel to (re)create a *contained* (!) *process* running a *well-known* *image*.

.image https://upload.wikimedia.org/wikipedia/commons/0/06/Containercrane.jpg _ 500
.caption container crane, container kraan in actie, illustratie is zelf gemaakt, Peter Welleman, CC-BY-SA-3.0, from Wikimedia Commons

* Container Engines

Any tool, or set of tools which can run _container_ _image_
(Synonym: container runtime)

Popular engines:
- docker
- rkt
- cri-o

And what about *Kubernetes*?
- management platform
- requires/runs on top a container runtime (docker, cri-o)

* meet runC (1/2)

.link https://blog.docker.com/2015/06/runc/ runc spawned from the docker codebase around 2015
runC is the de facto standard to run containers
runC cli interface treated as ABI
all the major management engines (possibly _all_) under the hood use runC

- docker itself
- cri-o
- containerd

* meet runC (2/2)

.image images/runc_containerd.png _ 1000
.caption the (simplified) containerd architecture

* how runC works (aka the heavy lifting)

to run a container, you need to setup some key management/containement features of the Linux kernel

- cgroups (possibly using systemd)
- SELinux (set up policy)
- seccomp (ditto)
- capabilities (drop privileges)
- ...
- *namespaces*

And therein, as the Bard would tell us, lies the rub.

* hurdles, when the less expected

.image https://upload.wikimedia.org/wikipedia/commons/a/a5/Hurdle_on_athletic_track.jpg _ 600
.caption Hurdle on athletic track by Santeri Viinamäki, CC BY-SA 4.0, from Wikimedia Commons

* setns

Each container runs in its own namespace(s)
Any container management tool need to move processes into another namespace. Or just enter different namespaces.

It boils down to changing namespaces. We can do that invoking a *sycall*

  setns - reassociate thread with a namespace

*Important*: namespace is a *thread* property


* it seems easy

  func runInsideNS() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    // we start in hostNs
    netns.Set(containerNs)  // we want to do work here
    defer netns.Set(hostNs) // we need to return here once done
    doStuff()
  }

.link https://groups.google.com/forum/#!topic/golang-nuts/ss1gEOcehjk/discussion turns out it is not.
.link https://www.weave.works/blog/linux-namespaces-and-go-don-t-mix (as other people found out)

* what's going on? (1/3)

goroutines (G) are multiplexed by the go scheduler on OS threads (M)
details:
.link https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.3ejixocv765a scheduler design document:

.image images/bug_samens.png _ 800

On linux, the implementation uses the `clone(2)` syscall.

when a goroutine does a blocking syscall, the golang runtime might create a new OS thread before entering or exiting the syscall

* parking headaches

Syscalls/M[OS Thread] *Parking* and *Unparking*

  When an M [OS thread] creates a new G[oroutine], it must ensure that
  there is another M [OS thread] to execute the G[oroutine]
  (if not all M[OS Threads]’s are already busy).
  Similarly, when an M [OS thread] enters syscall, it must ensure that
  there is another M[OS Thread] to execute Go code.

* what's going on? (2/3)

goroutines transparently created by the go scheduler
.link https://github.com/golang/go/blob/release-branch.go1.11/src/runtime/os_linux.go#L132 will have the same namespace as parent

.image images/bug_expected.png _ 800

* what's going on? (3/3)

So, if the runtime decided to spawn a new thread when your code was inside the "guest" namespace, the new thread will stay there forever

.image images/bug_actual.png _ 800

And your goroutine can randomly run in an unexpected namespace.

* but what about LockOSThread?

  func runInsideNS() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()
    netns.Set(containerNs)
    defer netns.Set(hostNs)
    doStuff()
  }


1. `runInsideNS` will indeed run always on the same goroutine
2. `runInsideNS` restores correctly the namespace
3. *however*, while `runInsideNS` runs, the go scheduler _may_ _create_ _a_ _new_ _OS_ _Thread_!
4. and that thread _will_ _inherit_ _the_ _NS_ _on_ _which_ `runInsideNS` _currently_ _runs_!


* more dark corners

maybe obvious for anyone but worth remembering:

(almost) every go program is multithreaded - it's just how the runtime is implemented!

it is pretty hard to fork a multithreaded program safely

.link http://www.evanjones.ca/fork-is-dangerous.html not just in golang btw

.link https://golang.org/pkg/syscall/#ForkExec this is why there isn't fork without exec in the standard library

.link https://github.com/golang/go/issues/227 so you may need to rethink how you daemonize your go program

maybe just use systemd? :)

* Finding solution(s)

.image https://upload.wikimedia.org/wikipedia/commons/c/cc/Spork_Plus.jpg _ 800
.caption plastic spork (plus) By CarbonNYC, CC BY 2.0, via Wikimedia Commons

* The "ugly", quick fix

Let's just spawn a helper process!

- it's effective!
- our binary is no longer self contained - sometimes a big deal, sometimes not
- spawning a helper is costly
- the helper will face the very same challenges - maybe use another language for the helper, say C? :)
- this is actually what few projects did

* I can't or wan't use helpers!

(Actually *NOT* "bad" at all, just complex but very clever)

How does libcontainer solve the namespace issue?
.link https://github.com/opencontainers/runc/tree/master/libcontainer/nsenter enter the nsenter package

Implemented in plain old C :)
(except the tests)

.link https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md Excerpt from the README:

  The nsenter package registers a special init constructor that is called before the Go
  runtime has a chance to boot.

Worth a closer look!

* a step back: what's this libcontainer thing?

We discovered `runc` is the core component of every major (possibly all) container runtime

.link https://github.com/opencontainers/runc/tree/master/libcontainer In turn libcontainer is the core component of runc

libcontainer is pretty tied to runc
This also is a project derived from the Docker sources (~2015)

So, let's look inside libcontainer

* jumping through hoops

.link https://github.com/opencontainers/runc/blob/master/libcontainer/README.md From the README of libcontainer:

  Using libcontainer

  Because containers are spawned in a two step process you will need a binary
  that will be executed as the init process for the container.
  In libcontainer, we use the current binary (/proc/self/exe) to be executed
  as the init process[...]


We may found a good reason why everyone is (re)using runc :)

* The nsenter flow

- hook up at the package import time, before goroutines get to run
- use a C helper to do all the real namespace switching dance
- The C helper has to fork() twice to enter the PID namespace correctly
- The C helper takes care of proper synchronization among temporary processes
- Synchronization is a multi-stage process (you need to set up stuff partially in child and partially in parent -e.g. maps)
- State machine to run code in the proper unix process

Let's have a look to the flow - from 10k meters, only the *major* steps

* nsenter from 10k meters 1/4

.image images/nsenter_stage_a.png 480 _
.caption do nothing if not asked to (reduce side effects as much as possible)

* nsenter from 10k meters 2/4

.image images/nsenter_stage_b.png 480 _
.caption use clone() to be able to specify NS sharing flags (- and also setjmp!)

* nsenter from 10k meters 3/4

.image images/nsenter_stage_c.png _ 800
.caption spawns a child and sets NS (et. al.)

* nsenter from 10k meters 4/4

.image images/nsenter_stage_d.png _ 720
.caption we need another child to actually enter the NS

* nsenter - takeaways

The `nsenter` package is actually a very interesting and solid package, built on many clever solutions

It is "bad" *ONLY* in the sense its implementation is complex, and requires a lot of help from the surrounding program
to be used effectively.

Actually, `runc` is built around `nsenter`

TL;DR: not drop-in solution

* The good solution: just use go >= 1.10

Three fixes merged in go 1.10

- #20676: No new thread will be created from a thread which is currently locked with runtime.LockOSThread.
- #20395: A locked thread will not be re-used to schedule other goroutines if a goroutine did not unlock it before exiting.
- #20458: If a thread was locked multiple times, runtime.UnlockOSThread has to be called equal number of times in order to unlock the thread.

Problem solved:

  // +build go1.10


* ... Problem really solved?


  func runInsideNS() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    netns.Set(containerNs)
    defer netns.Set(hostNs)

    go doOtherStuff()  // on which NS am I?

    doStuff()
  }


* Problem solved - if you are careful

Caution!
- the namespace is a *thread* property
- the go scheduler can run gorutines on any available thread

So:
- do not spawn goroutine in the scenario above
- you need to make sure that no packages you use spawn goroutines!

Maybe these two points can be checked by some automated tools in the future?

* wrap up

Changing namespace(s) in go is surprisingly hard

But isn't namespace a global property (of a thread, but still)?

So is this another reminder that managing state is hard (and global state is harder?)

*Especially* in concurrent programs

* Takeaways - the specific lessons

TODO

* Q? A!

Questions?

Slides & more @ https://github.com/mojaves/
